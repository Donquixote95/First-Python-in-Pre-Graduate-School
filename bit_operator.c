// 데이터를 비트 단위로 연산하는 연산자, 정수에만 사용 할 수 있다.

// 논리 연산; &, |, ^

// 이동 연산; >>, <<

//비트 연산자도 복합대입 연산자로 사용 할 수 있다.
// (~을) a = a <<2;
// (~으로) a <<= 2;
// &=, ^=, |=, <<=, >>=
// 단, 비트 부정 연산자(~)는 단항 연산자이므로 복합대입 연산자로 사용할 수 없다.

#include <stdio.h>

int main(void)
{
    int a = 10;  // 4바이트, 32비트 // 00000000 00000000 00000000 00001010 //10
    int b = 12;  // 4바이트, 32비트 // 00000000 00000000 00000000 00001100 //12

    printf("a & b : %d\n", a & b); //논리곱 ; 두 비트가 모두 1인 경우에만 1로 계산한다. // 00000000 00000000 00000000 00001000 //8
    printf("a ^ b : %d\n", a ^ b); //배타적 논리합(exclusiv or) ; 두 비트가 서로 다른 경우에만 1로 계산한다. // 00000000 00000000 00000000 00000110 //6
    printf("a | b : %d\n", a | b); //논리합 ; 두 비트 중 하나라도 참이면 1로 계산한다. // 00000000 00000000 00000000 00001110 //14

    printf("~a : %d\n", ~a); //부정연산자 ; 비트를 반전시킨다. // 11111111 11111111 11111111 11110101 //-11
    printf("a << 1 : %d\n", a << 1 ); //비트를 왼쪽으로 이동시킨다. 밀려나는 비트는 사라지고 오른쪽에 남는 비트는 0으로 채워진다.
                                      //한 칸 이동 시 각 자리수가 올라가기 때문에 10진수 기준으로 2씩 곱해진다.
                                      //00000000 00000000 00000000 00010100 //20 
    printf("a >> 2 : %d\n", a >> 2 ); //비트를 오른쪽으로 이동시킨다. 오른쪽으로 밀려나는 비트는 사라지고 왼쪽의 남는 비트는 부호 비트로 채운다.
                                      //2로 나눈 몫이 된다. 부호는 변하지 않는다.
                                      //단, 자료형이 unsigned로 선언되었다면 부호 비트의 의미가 없으므로 왼쪽의 남는 비트는 항상 0으로 채운다.
                                      //00000000 00000000 00000000 00000010 //2

    return 0 ;
}